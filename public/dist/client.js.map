{
  "version": 3,
  "sources": ["../../node_modules/partysocket/dist/chunk-54YSQCE5.mjs", "../../node_modules/partysocket/dist/chunk-4RHF3PCL.mjs", "../../server/src/client.ts"],
  "sourcesContent": ["// src/ws.ts\nif (!globalThis.EventTarget || !globalThis.Event) {\n  console.error(`\n  PartySocket requires a global 'EventTarget' class to be available!\n  You can use the 'event-target-shim' package to polyfill this. See https://www.npmjs.com/package/event-target-shim. \n  First, run:\n  \\`\\`\\`\n  npm install event-target-shim\n  \\`\\`\\`\n  Then, add this in your code:\n  \\`\\`\\`\n  import {Event, EventTarget} from 'event-target-shim';\n  if(!globalThis.Event) {\n    globalThis.Event = Event;\n  }\n  if(!globalThis.EventTarget) {\n    globalThis.EventTarget = EventTarget;\n  }\n  \\`\\`\\`\n  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.\n`);\n}\nvar ErrorEvent = class extends Event {\n  message;\n  error;\n  constructor(error, target) {\n    super(\"error\", target);\n    this.message = error.message;\n    this.error = error;\n  }\n};\nvar CloseEvent = class extends Event {\n  code;\n  reason;\n  wasClean = true;\n  constructor(code = 1e3, reason = \"\", target) {\n    super(\"close\", target);\n    this.code = code;\n    this.reason = reason;\n  }\n};\nvar Events = {\n  Event,\n  ErrorEvent,\n  CloseEvent\n};\nfunction assert(condition, msg) {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\nfunction cloneEvent(e) {\n  return new e.constructor(e.type, e);\n}\nvar DEFAULT = {\n  maxReconnectionDelay: 1e4,\n  minReconnectionDelay: 1e3 + Math.random() * 4e3,\n  minUptime: 5e3,\n  reconnectionDelayGrowFactor: 1.3,\n  connectionTimeout: 4e3,\n  maxRetries: Infinity,\n  maxEnqueuedMessages: Infinity,\n  startClosed: false,\n  debug: false\n};\nvar ReconnectingWebSocket = class _ReconnectingWebSocket extends EventTarget {\n  _ws;\n  _retryCount = -1;\n  _uptimeTimeout;\n  _connectTimeout;\n  _shouldReconnect = true;\n  _connectLock = false;\n  _binaryType = \"blob\";\n  _closeCalled = false;\n  _messageQueue = [];\n  _url;\n  _protocols;\n  _options;\n  constructor(url, protocols, options = {}) {\n    super();\n    this._url = url;\n    this._protocols = protocols;\n    this._options = options;\n    if (this._options.startClosed) {\n      this._shouldReconnect = false;\n    }\n    this._connect();\n  }\n  static get CONNECTING() {\n    return 0;\n  }\n  static get OPEN() {\n    return 1;\n  }\n  static get CLOSING() {\n    return 2;\n  }\n  static get CLOSED() {\n    return 3;\n  }\n  get CONNECTING() {\n    return _ReconnectingWebSocket.CONNECTING;\n  }\n  get OPEN() {\n    return _ReconnectingWebSocket.OPEN;\n  }\n  get CLOSING() {\n    return _ReconnectingWebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return _ReconnectingWebSocket.CLOSED;\n  }\n  get binaryType() {\n    return this._ws ? this._ws.binaryType : this._binaryType;\n  }\n  set binaryType(value) {\n    this._binaryType = value;\n    if (this._ws) {\n      this._ws.binaryType = value;\n    }\n  }\n  /**\n   * Returns the number or connection retries\n   */\n  get retryCount() {\n    return Math.max(this._retryCount, 0);\n  }\n  /**\n   * The number of bytes of data that have been queued using calls to send() but not yet\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\n   * this will continue to climb. Read only\n   */\n  get bufferedAmount() {\n    const bytes = this._messageQueue.reduce((acc, message) => {\n      if (typeof message === \"string\") {\n        acc += message.length;\n      } else if (message instanceof Blob) {\n        acc += message.size;\n      } else {\n        acc += message.byteLength;\n      }\n      return acc;\n    }, 0);\n    return bytes + (this._ws ? this._ws.bufferedAmount : 0);\n  }\n  /**\n   * The extensions selected by the server. This is currently only the empty string or a list of\n   * extensions as negotiated by the connection\n   */\n  get extensions() {\n    return this._ws ? this._ws.extensions : \"\";\n  }\n  /**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when creating the\n   * WebSocket object\n   */\n  get protocol() {\n    return this._ws ? this._ws.protocol : \"\";\n  }\n  /**\n   * The current state of the connection; this is one of the Ready state constants\n   */\n  get readyState() {\n    if (this._ws) {\n      return this._ws.readyState;\n    }\n    return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;\n  }\n  /**\n   * The URL as resolved by the constructor\n   */\n  get url() {\n    return this._ws ? this._ws.url : \"\";\n  }\n  /**\n   * Whether the websocket object is now in reconnectable state\n   */\n  get shouldReconnect() {\n    return this._shouldReconnect;\n  }\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\n   */\n  onclose = null;\n  /**\n   * An event listener to be called when an error occurs\n   */\n  onerror = null;\n  /**\n   * An event listener to be called when a message is received from the server\n   */\n  onmessage = null;\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data\n   */\n  onopen = null;\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the connection is already\n   * CLOSED, this method does nothing\n   */\n  close(code = 1e3, reason) {\n    this._closeCalled = true;\n    this._shouldReconnect = false;\n    this._clearTimeouts();\n    if (!this._ws) {\n      this._debug(\"close enqueued: no ws instance\");\n      return;\n    }\n    if (this._ws.readyState === this.CLOSED) {\n      this._debug(\"close: already closed\");\n      return;\n    }\n    this._ws.close(code, reason);\n  }\n  /**\n   * Closes the WebSocket connection or connection attempt and connects again.\n   * Resets retry counter;\n   */\n  reconnect(code, reason) {\n    this._shouldReconnect = true;\n    this._closeCalled = false;\n    this._retryCount = -1;\n    if (!this._ws || this._ws.readyState === this.CLOSED) {\n      this._connect();\n    } else {\n      this._disconnect(code, reason);\n      this._connect();\n    }\n  }\n  /**\n   * Enqueue specified data to be transmitted to the server over the WebSocket connection\n   */\n  send(data) {\n    if (this._ws && this._ws.readyState === this.OPEN) {\n      this._debug(\"send\", data);\n      this._ws.send(data);\n    } else {\n      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;\n      if (this._messageQueue.length < maxEnqueuedMessages) {\n        this._debug(\"enqueue\", data);\n        this._messageQueue.push(data);\n      }\n    }\n  }\n  _debug(...args) {\n    if (this._options.debug) {\n      console.log.apply(console, [\"RWS>\", ...args]);\n    }\n  }\n  _getNextDelay() {\n    const {\n      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,\n      minReconnectionDelay = DEFAULT.minReconnectionDelay,\n      maxReconnectionDelay = DEFAULT.maxReconnectionDelay\n    } = this._options;\n    let delay = 0;\n    if (this._retryCount > 0) {\n      delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);\n      if (delay > maxReconnectionDelay) {\n        delay = maxReconnectionDelay;\n      }\n    }\n    this._debug(\"next delay\", delay);\n    return delay;\n  }\n  _wait() {\n    return new Promise((resolve) => {\n      setTimeout(resolve, this._getNextDelay());\n    });\n  }\n  _getNextProtocols(protocolsProvider) {\n    if (!protocolsProvider)\n      return Promise.resolve(null);\n    if (typeof protocolsProvider === \"string\" || Array.isArray(protocolsProvider)) {\n      return Promise.resolve(protocolsProvider);\n    }\n    if (typeof protocolsProvider === \"function\") {\n      const protocols = protocolsProvider();\n      if (!protocols)\n        return Promise.resolve(null);\n      if (typeof protocols === \"string\" || Array.isArray(protocols)) {\n        return Promise.resolve(protocols);\n      }\n      if (protocols.then) {\n        return protocols;\n      }\n    }\n    throw Error(\"Invalid protocols\");\n  }\n  _getNextUrl(urlProvider) {\n    if (typeof urlProvider === \"string\") {\n      return Promise.resolve(urlProvider);\n    }\n    if (typeof urlProvider === \"function\") {\n      const url = urlProvider();\n      if (typeof url === \"string\") {\n        return Promise.resolve(url);\n      }\n      if (url.then) {\n        return url;\n      }\n    }\n    throw Error(\"Invalid URL\");\n  }\n  _connect() {\n    if (this._connectLock || !this._shouldReconnect) {\n      return;\n    }\n    this._connectLock = true;\n    const {\n      maxRetries = DEFAULT.maxRetries,\n      connectionTimeout = DEFAULT.connectionTimeout\n    } = this._options;\n    if (this._retryCount >= maxRetries) {\n      this._debug(\"max retries reached\", this._retryCount, \">=\", maxRetries);\n      return;\n    }\n    this._retryCount++;\n    this._debug(\"connect\", this._retryCount);\n    this._removeListeners();\n    this._wait().then(\n      () => Promise.all([\n        this._getNextUrl(this._url),\n        this._getNextProtocols(this._protocols || null)\n      ])\n    ).then(([url, protocols]) => {\n      if (this._closeCalled) {\n        this._connectLock = false;\n        return;\n      }\n      this._debug(\"connect\", { url, protocols });\n      this._ws = protocols ? new WebSocket(url, protocols) : new WebSocket(url);\n      this._ws.binaryType = this._binaryType;\n      this._connectLock = false;\n      this._addListeners();\n      this._connectTimeout = setTimeout(\n        () => this._handleTimeout(),\n        connectionTimeout\n      );\n    }).catch((err) => {\n      this._connectLock = false;\n      this._handleError(new Events.ErrorEvent(Error(err.message), this));\n    });\n  }\n  _handleTimeout() {\n    this._debug(\"timeout event\");\n    this._handleError(new Events.ErrorEvent(Error(\"TIMEOUT\"), this));\n  }\n  _disconnect(code = 1e3, reason) {\n    this._clearTimeouts();\n    if (!this._ws) {\n      return;\n    }\n    this._removeListeners();\n    try {\n      this._ws.close(code, reason);\n      this._handleClose(new Events.CloseEvent(code, reason, this));\n    } catch (error) {\n    }\n  }\n  _acceptOpen() {\n    this._debug(\"accept open\");\n    this._retryCount = 0;\n  }\n  _handleOpen = (event) => {\n    this._debug(\"open event\");\n    const { minUptime = DEFAULT.minUptime } = this._options;\n    clearTimeout(this._connectTimeout);\n    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);\n    assert(this._ws, \"WebSocket is not defined\");\n    this._ws.binaryType = this._binaryType;\n    this._messageQueue.forEach((message) => this._ws?.send(message));\n    this._messageQueue = [];\n    if (this.onopen) {\n      this.onopen(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n  _handleMessage = (event) => {\n    this._debug(\"message event\");\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n  _handleError = (event) => {\n    this._debug(\"error event\", event.message);\n    this._disconnect(\n      void 0,\n      event.message === \"TIMEOUT\" ? \"timeout\" : void 0\n    );\n    if (this.onerror) {\n      this.onerror(event);\n    }\n    this._debug(\"exec error listeners\");\n    this.dispatchEvent(cloneEvent(event));\n    this._connect();\n  };\n  _handleClose = (event) => {\n    this._debug(\"close event\");\n    this._clearTimeouts();\n    if (this._shouldReconnect) {\n      this._connect();\n    }\n    if (this.onclose) {\n      this.onclose(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n  _removeListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"removeListeners\");\n    this._ws.removeEventListener(\"open\", this._handleOpen);\n    this._ws.removeEventListener(\"close\", this._handleClose);\n    this._ws.removeEventListener(\"message\", this._handleMessage);\n    this._ws.removeEventListener(\"error\", this._handleError);\n  }\n  _addListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"addListeners\");\n    this._ws.addEventListener(\"open\", this._handleOpen);\n    this._ws.addEventListener(\"close\", this._handleClose);\n    this._ws.addEventListener(\"message\", this._handleMessage);\n    this._ws.addEventListener(\"error\", this._handleError);\n  }\n  _clearTimeouts() {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._uptimeTimeout);\n  }\n};\n\nexport {\n  ErrorEvent,\n  CloseEvent,\n  ReconnectingWebSocket\n};\n/*!\n * Reconnecting WebSocket\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\n * https://github.com/pladaria/reconnecting-websocket\n * License MIT\n */\n", "import {\n  ReconnectingWebSocket\n} from \"./chunk-54YSQCE5.mjs\";\n\n// src/index.ts\nfunction generateUUID() {\n  if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n    return crypto.randomUUID();\n  }\n  let d = (/* @__PURE__ */ new Date()).getTime();\n  let d2 = typeof performance !== \"undefined\" && performance.now && performance.now() * 1e3 || 0;\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n    let r = Math.random() * 16;\n    if (d > 0) {\n      r = (d + r) % 16 | 0;\n      d = Math.floor(d / 16);\n    } else {\n      r = (d2 + r) % 16 | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n    return (c === \"x\" ? r : r & 3 | 8).toString(16);\n  });\n}\nvar PartySocket = class extends ReconnectingWebSocket {\n  constructor(partySocketOptions) {\n    const {\n      host: rawHost,\n      room,\n      party,\n      protocol,\n      query,\n      protocols,\n      ...socketOptions\n    } = partySocketOptions;\n    const _pk = partySocketOptions.id || generateUUID();\n    const host = rawHost.replace(/^(http|https|ws|wss):\\/\\//, \"\");\n    let url = `${protocol || (host.startsWith(\"localhost:\") || host.startsWith(\"127.0.0.1:\") ? \"ws\" : \"wss\")}://${host}/${party ? `parties/${party}` : \"party\"}/${room}`;\n    if (query) {\n      url += `?${new URLSearchParams({ ...query, _pk }).toString()}`;\n    } else {\n      url += `?_pk=${_pk}`;\n    }\n    super(url, protocols, socketOptions);\n    this.partySocketOptions = partySocketOptions;\n    this._pk = _pk;\n  }\n  _pk;\n  get id() {\n    return this._pk;\n  }\n};\n\nexport {\n  PartySocket\n};\n", "import './styles.css';\n\nimport PartySocket from 'partysocket';\n\ndeclare const PARTYKIT_HOST: string;\n\n// Let's append all the messages we get into this DOM element\nconst output = document.getElementById('app') as HTMLDivElement;\n\n// Helper function to add a new line to the DOM\nfunction add(text: string) {\n  output.appendChild(document.createTextNode(text));\n  output.appendChild(document.createElement('br'));\n}\n\n// A PartySocket is like a WebSocket, except it's a bit more magical.\n// It handles reconnection logic, buffering messages while it's offline, and more.\nconst conn = new PartySocket({\n  host: PARTYKIT_HOST,\n  room: 'queue',\n  id: 'web-client',\n});\n\n// You can even start sending messages before the connection is open!\nconn.addEventListener('message', event => {\n  add(`${event.data}`);\n});\n\n// Let's listen for when the connection opens\n// And send a ping every 2 seconds right after\nconn.addEventListener('open', () => {\n  add('Connected!');\n  add('Sending a ping every 2 seconds...');\n  // TODO: make this more interesting / nice\n  setInterval(() => {\n    conn.send(JSON.stringify({type: 'ping', message: 'ping from web client'}));\n  }, 2000);\n});\n"],
  "mappings": "CACI,CAAC,WAAW,aAAe,CAAC,WAAW,QACzC,QAAQ,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAkBf,EAED,IAAIA,EAAa,cAAc,KAAM,CACnC,QACA,MACA,YAAYC,EAAOC,EAAQ,CACzB,MAAM,QAASA,CAAM,EACrB,KAAK,QAAUD,EAAM,QACrB,KAAK,MAAQA,CACf,CACF,EACIE,EAAa,cAAc,KAAM,CACnC,KACA,OACA,SAAW,GACX,YAAYC,EAAO,IAAKC,EAAS,GAAIH,EAAQ,CAC3C,MAAM,QAASA,CAAM,EACrB,KAAK,KAAOE,EACZ,KAAK,OAASC,CAChB,CACF,EACIC,EAAS,CACX,MACA,WAAAN,EACA,WAAAG,CACF,EACA,SAASI,EAAOC,EAAWC,EAAK,CAC9B,GAAI,CAACD,EACH,MAAM,IAAI,MAAMC,CAAG,CAEvB,CACA,SAASC,EAAWC,EAAG,CACrB,OAAO,IAAIA,EAAE,YAAYA,EAAE,KAAMA,CAAC,CACpC,CACA,IAAIC,EAAU,CACZ,qBAAsB,IACtB,qBAAsB,IAAM,KAAK,OAAO,EAAI,IAC5C,UAAW,IACX,4BAA6B,IAC7B,kBAAmB,IACnB,WAAY,IACZ,oBAAqB,IACrB,YAAa,GACb,MAAO,EACT,EACIC,EAAwB,MAAMC,UAA+B,WAAY,CAC3E,IACA,YAAc,GACd,eACA,gBACA,iBAAmB,GACnB,aAAe,GACf,YAAc,OACd,aAAe,GACf,cAAgB,CAAC,EACjB,KACA,WACA,SACA,YAAYC,EAAKC,EAAWC,EAAU,CAAC,EAAG,CACxC,MAAM,EACN,KAAK,KAAOF,EACZ,KAAK,WAAaC,EAClB,KAAK,SAAWC,EACZ,KAAK,SAAS,cAChB,KAAK,iBAAmB,IAE1B,KAAK,SAAS,CAChB,CACA,WAAW,YAAa,CACtB,MAAO,EACT,CACA,WAAW,MAAO,CAChB,MAAO,EACT,CACA,WAAW,SAAU,CACnB,MAAO,EACT,CACA,WAAW,QAAS,CAClB,MAAO,EACT,CACA,IAAI,YAAa,CACf,OAAOH,EAAuB,UAChC,CACA,IAAI,MAAO,CACT,OAAOA,EAAuB,IAChC,CACA,IAAI,SAAU,CACZ,OAAOA,EAAuB,OAChC,CACA,IAAI,QAAS,CACX,OAAOA,EAAuB,MAChC,CACA,IAAI,YAAa,CACf,OAAO,KAAK,IAAM,KAAK,IAAI,WAAa,KAAK,WAC/C,CACA,IAAI,WAAWI,EAAO,CACpB,KAAK,YAAcA,EACf,KAAK,MACP,KAAK,IAAI,WAAaA,EAE1B,CAIA,IAAI,YAAa,CACf,OAAO,KAAK,IAAI,KAAK,YAAa,CAAC,CACrC,CAOA,IAAI,gBAAiB,CAWnB,OAVc,KAAK,cAAc,OAAO,CAACC,EAAKC,KACxC,OAAOA,GAAY,SACrBD,GAAOC,EAAQ,OACNA,aAAmB,KAC5BD,GAAOC,EAAQ,KAEfD,GAAOC,EAAQ,WAEVD,GACN,CAAC,GACY,KAAK,IAAM,KAAK,IAAI,eAAiB,EACvD,CAKA,IAAI,YAAa,CACf,OAAO,KAAK,IAAM,KAAK,IAAI,WAAa,EAC1C,CAMA,IAAI,UAAW,CACb,OAAO,KAAK,IAAM,KAAK,IAAI,SAAW,EACxC,CAIA,IAAI,YAAa,CACf,OAAI,KAAK,IACA,KAAK,IAAI,WAEX,KAAK,SAAS,YAAcL,EAAuB,OAASA,EAAuB,UAC5F,CAIA,IAAI,KAAM,CACR,OAAO,KAAK,IAAM,KAAK,IAAI,IAAM,EACnC,CAIA,IAAI,iBAAkB,CACpB,OAAO,KAAK,gBACd,CAIA,QAAU,KAIV,QAAU,KAIV,UAAY,KAKZ,OAAS,KAKT,MAAMV,EAAO,IAAKC,EAAQ,CAIxB,GAHA,KAAK,aAAe,GACpB,KAAK,iBAAmB,GACxB,KAAK,eAAe,EAChB,CAAC,KAAK,IAAK,CACb,KAAK,OAAO,gCAAgC,EAC5C,MACF,CACA,GAAI,KAAK,IAAI,aAAe,KAAK,OAAQ,CACvC,KAAK,OAAO,uBAAuB,EACnC,MACF,CACA,KAAK,IAAI,MAAMD,EAAMC,CAAM,CAC7B,CAKA,UAAUD,EAAMC,EAAQ,CACtB,KAAK,iBAAmB,GACxB,KAAK,aAAe,GACpB,KAAK,YAAc,GACf,CAAC,KAAK,KAAO,KAAK,IAAI,aAAe,KAAK,OAC5C,KAAK,SAAS,GAEd,KAAK,YAAYD,EAAMC,CAAM,EAC7B,KAAK,SAAS,EAElB,CAIA,KAAKgB,EAAM,CACT,GAAI,KAAK,KAAO,KAAK,IAAI,aAAe,KAAK,KAC3C,KAAK,OAAO,OAAQA,CAAI,EACxB,KAAK,IAAI,KAAKA,CAAI,MACb,CACL,GAAM,CAAE,oBAAAC,EAAsBV,EAAQ,mBAAoB,EAAI,KAAK,SAC/D,KAAK,cAAc,OAASU,IAC9B,KAAK,OAAO,UAAWD,CAAI,EAC3B,KAAK,cAAc,KAAKA,CAAI,EAEhC,CACF,CACA,UAAUE,EAAM,CACV,KAAK,SAAS,OAChB,QAAQ,IAAI,MAAM,QAAS,CAAC,OAAQ,GAAGA,CAAI,CAAC,CAEhD,CACA,eAAgB,CACd,GAAM,CACJ,4BAAAC,EAA8BZ,EAAQ,4BACtC,qBAAAa,EAAuBb,EAAQ,qBAC/B,qBAAAc,EAAuBd,EAAQ,oBACjC,EAAI,KAAK,SACLe,EAAQ,EACZ,OAAI,KAAK,YAAc,IACrBA,EAAQF,EAAuB,KAAK,IAAID,EAA6B,KAAK,YAAc,CAAC,EACrFG,EAAQD,IACVC,EAAQD,IAGZ,KAAK,OAAO,aAAcC,CAAK,EACxBA,CACT,CACA,OAAQ,CACN,OAAO,IAAI,QAASC,GAAY,CAC9B,WAAWA,EAAS,KAAK,cAAc,CAAC,CAC1C,CAAC,CACH,CACA,kBAAkBC,EAAmB,CACnC,GAAI,CAACA,EACH,OAAO,QAAQ,QAAQ,IAAI,EAC7B,GAAI,OAAOA,GAAsB,UAAY,MAAM,QAAQA,CAAiB,EAC1E,OAAO,QAAQ,QAAQA,CAAiB,EAE1C,GAAI,OAAOA,GAAsB,WAAY,CAC3C,IAAMb,EAAYa,EAAkB,EACpC,GAAI,CAACb,EACH,OAAO,QAAQ,QAAQ,IAAI,EAC7B,GAAI,OAAOA,GAAc,UAAY,MAAM,QAAQA,CAAS,EAC1D,OAAO,QAAQ,QAAQA,CAAS,EAElC,GAAIA,EAAU,KACZ,OAAOA,CAEX,CACA,MAAM,MAAM,mBAAmB,CACjC,CACA,YAAYc,EAAa,CACvB,GAAI,OAAOA,GAAgB,SACzB,OAAO,QAAQ,QAAQA,CAAW,EAEpC,GAAI,OAAOA,GAAgB,WAAY,CACrC,IAAMf,EAAMe,EAAY,EACxB,GAAI,OAAOf,GAAQ,SACjB,OAAO,QAAQ,QAAQA,CAAG,EAE5B,GAAIA,EAAI,KACN,OAAOA,CAEX,CACA,MAAM,MAAM,aAAa,CAC3B,CACA,UAAW,CACT,GAAI,KAAK,cAAgB,CAAC,KAAK,iBAC7B,OAEF,KAAK,aAAe,GACpB,GAAM,CACJ,WAAAgB,EAAanB,EAAQ,WACrB,kBAAAoB,EAAoBpB,EAAQ,iBAC9B,EAAI,KAAK,SACT,GAAI,KAAK,aAAemB,EAAY,CAClC,KAAK,OAAO,sBAAuB,KAAK,YAAa,KAAMA,CAAU,EACrE,MACF,CACA,KAAK,cACL,KAAK,OAAO,UAAW,KAAK,WAAW,EACvC,KAAK,iBAAiB,EACtB,KAAK,MAAM,EAAE,KACX,IAAM,QAAQ,IAAI,CAChB,KAAK,YAAY,KAAK,IAAI,EAC1B,KAAK,kBAAkB,KAAK,YAAc,IAAI,CAChD,CAAC,CACH,EAAE,KAAK,CAAC,CAAChB,EAAKC,CAAS,IAAM,CAC3B,GAAI,KAAK,aAAc,CACrB,KAAK,aAAe,GACpB,MACF,CACA,KAAK,OAAO,UAAW,CAAE,IAAAD,EAAK,UAAAC,CAAU,CAAC,EACzC,KAAK,IAAMA,EAAY,IAAI,UAAUD,EAAKC,CAAS,EAAI,IAAI,UAAUD,CAAG,EACxE,KAAK,IAAI,WAAa,KAAK,YAC3B,KAAK,aAAe,GACpB,KAAK,cAAc,EACnB,KAAK,gBAAkB,WACrB,IAAM,KAAK,eAAe,EAC1BiB,CACF,CACF,CAAC,EAAE,MAAOC,GAAQ,CAChB,KAAK,aAAe,GACpB,KAAK,aAAa,IAAI3B,EAAO,WAAW,MAAM2B,EAAI,OAAO,EAAG,IAAI,CAAC,CACnE,CAAC,CACH,CACA,gBAAiB,CACf,KAAK,OAAO,eAAe,EAC3B,KAAK,aAAa,IAAI3B,EAAO,WAAW,MAAM,SAAS,EAAG,IAAI,CAAC,CACjE,CACA,YAAYF,EAAO,IAAKC,EAAQ,CAE9B,GADA,KAAK,eAAe,EAChB,EAAC,KAAK,IAGV,MAAK,iBAAiB,EACtB,GAAI,CACF,KAAK,IAAI,MAAMD,EAAMC,CAAM,EAC3B,KAAK,aAAa,IAAIC,EAAO,WAAWF,EAAMC,EAAQ,IAAI,CAAC,CAC7D,MAAgB,CAChB,EACF,CACA,aAAc,CACZ,KAAK,OAAO,aAAa,EACzB,KAAK,YAAc,CACrB,CACA,YAAe6B,GAAU,CACvB,KAAK,OAAO,YAAY,EACxB,GAAM,CAAE,UAAAC,EAAYvB,EAAQ,SAAU,EAAI,KAAK,SAC/C,aAAa,KAAK,eAAe,EACjC,KAAK,eAAiB,WAAW,IAAM,KAAK,YAAY,EAAGuB,CAAS,EACpE5B,EAAO,KAAK,IAAK,0BAA0B,EAC3C,KAAK,IAAI,WAAa,KAAK,YAC3B,KAAK,cAAc,QAASa,GAAY,KAAK,KAAK,KAAKA,CAAO,CAAC,EAC/D,KAAK,cAAgB,CAAC,EAClB,KAAK,QACP,KAAK,OAAOc,CAAK,EAEnB,KAAK,cAAcxB,EAAWwB,CAAK,CAAC,CACtC,EACA,eAAkBA,GAAU,CAC1B,KAAK,OAAO,eAAe,EACvB,KAAK,WACP,KAAK,UAAUA,CAAK,EAEtB,KAAK,cAAcxB,EAAWwB,CAAK,CAAC,CACtC,EACA,aAAgBA,GAAU,CACxB,KAAK,OAAO,cAAeA,EAAM,OAAO,EACxC,KAAK,YACH,OACAA,EAAM,UAAY,UAAY,UAAY,MAC5C,EACI,KAAK,SACP,KAAK,QAAQA,CAAK,EAEpB,KAAK,OAAO,sBAAsB,EAClC,KAAK,cAAcxB,EAAWwB,CAAK,CAAC,EACpC,KAAK,SAAS,CAChB,EACA,aAAgBA,GAAU,CACxB,KAAK,OAAO,aAAa,EACzB,KAAK,eAAe,EAChB,KAAK,kBACP,KAAK,SAAS,EAEZ,KAAK,SACP,KAAK,QAAQA,CAAK,EAEpB,KAAK,cAAcxB,EAAWwB,CAAK,CAAC,CACtC,EACA,kBAAmB,CACZ,KAAK,MAGV,KAAK,OAAO,iBAAiB,EAC7B,KAAK,IAAI,oBAAoB,OAAQ,KAAK,WAAW,EACrD,KAAK,IAAI,oBAAoB,QAAS,KAAK,YAAY,EACvD,KAAK,IAAI,oBAAoB,UAAW,KAAK,cAAc,EAC3D,KAAK,IAAI,oBAAoB,QAAS,KAAK,YAAY,EACzD,CACA,eAAgB,CACT,KAAK,MAGV,KAAK,OAAO,cAAc,EAC1B,KAAK,IAAI,iBAAiB,OAAQ,KAAK,WAAW,EAClD,KAAK,IAAI,iBAAiB,QAAS,KAAK,YAAY,EACpD,KAAK,IAAI,iBAAiB,UAAW,KAAK,cAAc,EACxD,KAAK,IAAI,iBAAiB,QAAS,KAAK,YAAY,EACtD,CACA,gBAAiB,CACf,aAAa,KAAK,eAAe,EACjC,aAAa,KAAK,cAAc,CAClC,CACF,EC/aA,SAASE,GAAe,CACtB,GAAI,OAAO,OAAW,KAAe,OAAO,WAC1C,OAAO,OAAO,WAAW,EAE3B,IAAIC,EAAqB,IAAI,KAAK,EAAG,QAAQ,EACzCC,EAAK,OAAO,YAAgB,KAAe,YAAY,KAAO,YAAY,IAAI,EAAI,KAAO,EAC7F,MAAO,uCAAuC,QAAQ,QAAS,SAASC,EAAG,CACzE,IAAIC,EAAI,KAAK,OAAO,EAAI,GACxB,OAAIH,EAAI,GACNG,GAAKH,EAAIG,GAAK,GAAK,EACnBH,EAAI,KAAK,MAAMA,EAAI,EAAE,IAErBG,GAAKF,EAAKE,GAAK,GAAK,EACpBF,EAAK,KAAK,MAAMA,EAAK,EAAE,IAEjBC,IAAM,IAAMC,EAAIA,EAAI,EAAI,GAAG,SAAS,EAAE,CAChD,CAAC,CACH,CACA,IAAIC,EAAc,cAAcC,CAAsB,CACpD,YAAYC,EAAoB,CAC9B,GAAM,CACJ,KAAMC,EACN,KAAAC,EACA,MAAAC,EACA,SAAAC,EACA,MAAAC,EACA,UAAAC,EACA,GAAGC,CACL,EAAIP,EACEQ,EAAMR,EAAmB,IAAMP,EAAa,EAC5CgB,EAAOR,EAAQ,QAAQ,4BAA6B,EAAE,EACxDS,EAAM,GAAGN,IAAaK,EAAK,WAAW,YAAY,GAAKA,EAAK,WAAW,YAAY,EAAI,KAAO,MAAM,MAAMA,CAAI,IAAIN,EAAQ,WAAWA,CAAK,GAAK,OAAO,IAAID,CAAI,GAC9JG,EACFK,GAAO,IAAI,IAAI,gBAAgB,CAAE,GAAGL,EAAO,IAAAG,CAAI,CAAC,EAAE,SAAS,CAAC,GAE5DE,GAAO,QAAQF,CAAG,GAEpB,MAAME,EAAKJ,EAAWC,CAAa,EACnC,KAAK,mBAAqBP,EAC1B,KAAK,IAAMQ,CACb,CACA,IACA,IAAI,IAAK,CACP,OAAO,KAAK,GACd,CACF,EC3CA,IAAMG,EAAS,SAAS,eAAe,KAAK,EAG5C,SAASC,EAAIC,EAAc,CACzBF,EAAO,YAAY,SAAS,eAAeE,CAAI,CAAC,EAChDF,EAAO,YAAY,SAAS,cAAc,IAAI,CAAC,CACjD,CAIA,IAAMG,EAAO,IAAIC,EAAY,CAC3B,KAAM,sCACN,KAAM,QACN,GAAI,YACN,CAAC,EAGDD,EAAK,iBAAiB,UAAWE,GAAS,CACxCJ,EAAI,GAAGI,EAAM,IAAI,EAAE,CACrB,CAAC,EAIDF,EAAK,iBAAiB,OAAQ,IAAM,CAClCF,EAAI,YAAY,EAChBA,EAAI,mCAAmC,EAEvC,YAAY,IAAM,CAChBE,EAAK,KAAK,KAAK,UAAU,CAAC,KAAM,OAAQ,QAAS,sBAAsB,CAAC,CAAC,CAC3E,EAAG,GAAI,CACT,CAAC",
  "names": ["ErrorEvent", "error", "target", "CloseEvent", "code", "reason", "Events", "assert", "condition", "msg", "cloneEvent", "e", "DEFAULT", "ReconnectingWebSocket", "_ReconnectingWebSocket", "url", "protocols", "options", "value", "acc", "message", "data", "maxEnqueuedMessages", "args", "reconnectionDelayGrowFactor", "minReconnectionDelay", "maxReconnectionDelay", "delay", "resolve", "protocolsProvider", "urlProvider", "maxRetries", "connectionTimeout", "err", "event", "minUptime", "generateUUID", "d", "d2", "c", "r", "PartySocket", "ReconnectingWebSocket", "partySocketOptions", "rawHost", "room", "party", "protocol", "query", "protocols", "socketOptions", "_pk", "host", "url", "output", "add", "text", "conn", "PartySocket", "event"]
}
